{"version":3,"file":"index.cjs.production.min.cjs","sources":["../src/index.ts"],"sourcesContent":["import indentString, { Options as IIndentOptions } from 'indent-string';\nimport _cleanStack from 'clean-stack';\nimport { inspect } from 'util';\nimport { isIterable } from 'check-iterable';\nimport { array_unique_overwrite } from 'array-hyper-unique';\nimport { getSubErrors } from 'err-errors';\nimport { errStackReduceCore, IOptions as IErrStackReduceOptions } from 'err-stack-reduce';\nimport { stringifyStackMeta } from 'err-stack-meta';\nimport { parseStack } from 'error-stack2';\n\nexport interface IOptions<T = any>\n{\n\terror?: Error;\n\n\thandleStack?(stack: string, error: T): string;\n\n\t/**\n\t * @default 4\n\t */\n\tindent?: number,\n\n\t/**\n\t * options for `indent-string`\n\t */\n\tindentOptions?: IIndentOptions,\n\n\tstackReduceOptions?: IErrStackReduceOptions,\n}\n\nexport type IIterableLike<T = any> = Iterable<T> | IterableIterator<T>;\nexport type IIterableAllowed<T, A extends IIterableLike<T>> = Exclude<A, string | String>;\n\nexport function _isAllowedIterable(arr: any)\n{\n\treturn (typeof arr !== 'string' && !(arr instanceof String) && isIterable(arr))\n}\n\nexport function errorsToMessageList<T, A extends IIterableLike<T> = IIterableLike<T>>(errors: IIterableAllowed<T, A>,\n\toptions?: IOptions<T>,\n\tmainError?: Error,\n)\n{\n\tif (!errors || !_isAllowedIterable(errors))\n\t{\n\t\tthrow new TypeError(`Invalid input errors: ${errors}`)\n\t}\n\n\toptions ??= {};\n\n\tconst { handleStack = (stack: string) => _cleanStack(stack) } = options;\n\n\tmainError ??= options.error;\n\n\tlet _main: string;\n\n\tlet ls: string[] = [];\n\n\tconst stackReduce = errStackReduceCore(mainError, options.stackReduceOptions);\n\n\t(errors as any as (T & Error)[])\n\t\t.forEach((error) =>\n\t\t{\n\t\t\tif (error === void 0 || error === null)\n\t\t\t{\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (mainError === error)\n\t\t\t{\n\t\t\t\t_main = String(error)\n\t\t\t}\n\t\t\telse if (typeof error.stack === 'string')\n\t\t\t{\n\t\t\t\tls.push(handleStack(stringifyStackMeta(stackReduce(error)), error))\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tls.push(inspect(error))\n\t\t\t}\n\n\t\t})\n\t;\n\n\tls = ls.filter(s => s?.length)\n\n\tif (_main?.length)\n\t{\n\t\tls.unshift(_main)\n\t}\n\n\treturn array_unique_overwrite(ls)\n}\n\nexport function indentSubErrorMessage(sub_message: string | IIterableLike<string>, options?: IOptions)\n{\n\tif (_isAllowedIterable(sub_message))\n\t{\n\t\tsub_message = [...sub_message].join('\\n');\n\t}\n\n\toptions ??= {};\n\n\treturn indentString(sub_message as string, options.indent ?? 4, options.indentOptions)\n}\n\nexport function indentSubErrors<T, A extends IIterableLike<T> = IIterableLike<T>>(errors: IIterableAllowed<T, A>,\n\toptions?: IOptions<T>,\n\tmainError?: Error,\n)\n{\n\tconst sub_message = errorsToMessageList(errors, options, mainError);\n\treturn indentSubErrorMessage(sub_message, options);\n}\n\nexport function indentSubErrorsFromError<T, A extends IIterableLike<T> = IIterableLike<T>>(mainError?: Error,\n\toptions?: IOptions<T>,\n)\n{\n\tlet errors = getSubErrors(mainError) as IIterableAllowed<T, A>;\n\n\treturn indentSubErrors(errors, options, mainError)\n}\n\nexport function messageWithSubErrors<T, A extends IIterableLike<T> = IIterableLike<T>>(mainError: Error,\n\terrors?: IIterableAllowed<T, A>,\n\toptions?: IOptions<T>,\n)\n{\n\terrors ??= getSubErrors(mainError) as IIterableAllowed<T, A>;\n\n\tlet _e = parseStack(mainError.stack, mainError.message);\n\n\tlet lines = [] as string[];\n\n\tif (typeof _e.message !== 'undefined')\n\t{\n\t\tlines.push(_e.message);\n\t}\n\n\tlet _em2 = indentSubErrors(errors, options, mainError);\n\n\tif (_em2.length)\n\t{\n\t\tif (lines.length === 0)\n\t\t{\n\t\t\tlines.push('');\n\t\t}\n\t\tlines.push(_em2);\n\t}\n\n\tif (lines.length)\n\t{\n\t\treturn lines.join('\\n')\n\t}\n\n\treturn void 0;\n}\n\nexport default messageWithSubErrors\n"],"names":["_isAllowedIterable","arr","String","isIterable","errorsToMessageList","errors","options","mainError","_options","_mainError","_main2","TypeError","handleStack","stack","_cleanStack","_main","error","ls","stackReduce","errStackReduceCore","stackReduceOptions","forEach","push","stringifyStackMeta","inspect","filter","s","length","unshift","array_unique_overwrite","indentSubErrorMessage","sub_message","_options2","_options$indent","join","indentString","indent","indentOptions","indentSubErrors","messageWithSubErrors","_errors","getSubErrors","_e","parseStack","message","lines","_em2","indentSubErrorsFromError"],"mappings":";;;;;;;;AAgCM,SAAUA,mBAAmBC;EAElC,OAAuB,mBAARA,OAAsBA,aAAeC,WAAWC,EAAAA,WAAWF;AAC3E;;SAEgBG,oBAAsEC,GACrFC,GACAC;EAAiB,IAAAC,GAAAC,GAAAC;EAGjB,KAAKL,MAAWL,mBAAmBK,IAElC,MAAM,IAAIM,UAAU,yBAAyBN;EAGvCG,UAAPA,IAAAF,WAAOE,MAAAA,MAAPF,IAAY;EAEZ,OAAMM,aAAEA,IAAeC,MAAkBC,EAAYD,OAAWP;EAIhE,IAAIS;EAFK,UAATN,IAAAF,WAAS,MAAAE,MAATF,IAAcD,EAAQU;EAItB,IAAIC,IAAe;EAEnB,MAAMC,IAAcC,EAAkBA,mBAACZ,GAAWD,EAAQc;EAiC1D,OA/BCf,EACCgB,SAASL;IAELA,cAKAT,MAAcS,IAEjBD,IAAQb,OAAOc,KAIfC,EAAGK,KAF4B,mBAAhBN,EAAMH,QAEbD,EAAYW,EAAkBA,mBAACL,EAAYF,KAASA,KAIpDQ,UAAQR;AACjB,OAKFC,IAAKA,EAAGQ,QAAOC,KAAKA,iBAAC,IAADA,EAAGC,UAEd,UAATjB,IAAIK,WAAAL,MAAKA,KAALA,EAAOiB,UAEVV,EAAGW,QAAQb;EAGLc,EAAAA,uBAAuBZ;AAC/B;;AAEgB,SAAAa,sBAAsBC,GAA6CzB;EAAkB,IAAA0B,GAAAC;EASpG,OAPIjC,mBAAmB+B,OAEtBA,IAAc,KAAIA,IAAaG,KAAK,QAG9BF,UAAPA,IAAA1B,WAAO0B,MAAAA,MAAP1B,IAAY;EAEL6B,EAAaJ,aAAqBE,IAAE3B,EAAQ8B,gBAAM,MAAAH,IAAAA,IAAI,GAAG3B,EAAQ+B;AACzE;;SAEgBC,gBAAkEjC,GACjFC,GACAC;EAIA,OAAOuB,sBADa1B,oBAAoBC,GAAQC,GAASC,IACfD;AAC3C;;SAWgBiC,qBAAuEhC,GACtFF,GACAC;EAAqB,IAAAkC;EAGf,UAANA,IAAAnC,WAAM,MAAAmC,MAANnC,IAAWoC,eAAalC;EAExB,IAAImC,IAAKC,EAAAA,WAAWpC,EAAUM,OAAON,EAAUqC,UAE3CC,IAAQ;OAEc,MAAfH,EAAGE,WAEbC,EAAMvB,KAAKoB,EAAGE;EAGf,IAAIE,IAAOR,gBAAgBjC,GAAQC,GAASC;EAW5C,IATIuC,EAAKnB,WAEa,MAAjBkB,EAAMlB,UAETkB,EAAMvB,KAAK,KAEZuB,EAAMvB,KAAKwB,KAGRD,EAAMlB,QAET,OAAOkB,EAAMX,KAAK;AAIpB;;;;8EA1CgB,SAAAa,yBAA2ExC,GAC1FD;EAKA,OAAOgC,gBAFMG,eAAalC,IAEKD,GAASC;AACzC"}