{"version":3,"file":"index.esm.mjs","sources":["../src/util/trim.ts","../src/util/isUnset.ts","../src/util/isNumOnly.ts","../src/index.ts"],"sourcesContent":["export function trim(s: string)\n{\n\treturn s.trim();\n}\n","\nexport function isUnset(v: any): v is undefined | null\n{\n\treturn typeof v === 'undefined' || v === null\n}\n","\nexport function isNumOnly(v: any)\n{\n\tif (typeof v === 'number' || typeof v === 'string')\n\t{\n\t\treturn /^\\d+$/.test(v.toString())\n\t}\n\n\treturn false\n}\n","import { ITSPickExtra, ITSRequireAtLeastOne } from 'ts-type/lib/type/record';\nimport { lineSplit, R_CRLF, LF } from 'crlf-normalize';\nimport { IEvalTrace, IParsed, IParsedWithoutTrace, ISource, ITrace, IRawLineTrace, ITraceValue } from './types';\nimport { stringSplitWithLimit } from 'string-split-keep2';\nimport { trim } from './util/trim';\nimport { isUnset } from './util/isUnset';\nimport { isNumOnly } from './util/isNumOnly';\nimport errcode from 'err-code';\nimport { inspect } from 'util';\nimport { detectIndentLine } from 'string-detect-indent';\n\nconst AT = 'at' as const\n\n// 1.\n// Error: foo\n// 2.\n// TypeError: foo\nconst REGEX_MATCH_MESSAGE = /^([a-z][a-z0-9_]*)(?:(?: \\[(\\w+)\\])?:(?: ([\\s\\S]*))?)?$/i\n\nconst REGEX_MATCH_MESSAGE_LOOSE = new RegExp(REGEX_MATCH_MESSAGE.source, REGEX_MATCH_MESSAGE.flags + 'm');\n\nconst REGEX_REMOVE_AT = /^at\\s+/\nconst REGEX_STARTS_WITH_EVAL_AT = /^eval\\s+at\\s+/\n\nexport function breakBrackets(str: string, first: string, last: string)\n{\n\tif (!str.endsWith(last))\n\t{\n\t\treturn [str]\n\t}\n\n\tlet firstIndex\n\tlet cursor = str.length - 1\n\t// There is already the last one\n\tlet count = 1\n\twhile (--cursor >= 0)\n\t{\n\t\tconst char = str.charAt(cursor)\n\t\tif (char === last)\n\t\t{\n\t\t\tcount++\n\t\t}\n\t\telse if (char === first)\n\t\t{\n\t\t\tif (--count === 0)\n\t\t\t{\n\t\t\t\tfirstIndex = cursor\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn [\n\t\tstr.slice(0, firstIndex),\n\t\tstr.slice(firstIndex + 1, -1),\n\t].map(trim)\n}\n\nexport function validPosition(source: {\n\tline?: string | number,\n\tcol?: string | number,\n})\n{\n\tif (!isUnset(source))\n\t{\n\t\tif (typeof source === 'object' && isUnset(source.line) && isUnset(source.col))\n\t\t{\n\t\t\treturn null\n\t\t}\n\n\t\treturn isNumOnly(source.line) && isNumOnly(source.col)\n\t}\n\n\treturn false\n}\n\nexport function parseSource(rawSource: string): ISource\n{\n\tconst [source, line, col] = stringSplitWithLimit(rawSource, ':', -3);\n\n\tif (!col?.length || !line?.length)\n\t{\n\t\treturn {\n\t\t\tsource: rawSource,\n\t\t}\n\t}\n\n\treturn {\n\t\tsource,\n\t\tline,\n\t\tcol,\n\t}\n}\n\nexport function parseEvalSource(rawEvalSource: string): Omit<IEvalTrace, 'callee' | 'calleeNote' | 'eval'>\n{\n\tconst { indent, rawLine } = _detectIndent(rawEvalSource);\n\n\tconst [rawTrace, rawEvalTrace] = rawLine\n\t\t.replace(REGEX_STARTS_WITH_EVAL_AT, '')\n\t\t.split(/,\\s+/g)\n\t\t.map(trim)\n\n\tconst {\n\t\teval: ev,\n\t\tcallee: evalCallee,\n\t\tcalleeNote: evalCalleeNote,\n\t\t...trace\n\t} = parseTrace(rawTrace)\n\n\tconst evalTrace = parseSource(rawEvalTrace)\n\n\treturn {\n\t\tevalCallee,\n\t\tevalCalleeNote,\n\t\t...trace,\n\t\tevalTrace,\n\t\tindent,\n\t}\n}\n\nexport function _detectIndent(trace: string)\n{\n\tconst { indent, body: rawLine } = detectIndentLine(trace);\n\n\treturn {\n\t\tindent,\n\t\trawLine,\n\t}\n}\n\nexport function parseTrace(trace: string, testEvalSource: true): ITrace | IRawLineTrace\nexport function parseTrace(trace: string, testEvalSource?: false): ITrace\nexport function parseTrace(trace: string, testEvalSource?: boolean): ITrace | IRawLineTrace\nexport function parseTrace(trace: string, testEvalSource?: boolean)\n{\n\tconst { indent, rawLine } = _detectIndent(trace);\n\n\tconst t = rawLine.replace(REGEX_REMOVE_AT, '')\n\n\tlet [\n\t\trawCallee, rawSource,\n\t] = breakBrackets(t, '(', ')')\n\n\tif (!rawSource)\n\t{\n\t\t[rawCallee, rawSource] = [rawSource, rawCallee]\n\t}\n\n\tconst ret: ITrace = {} as any\n\n\tif (rawCallee)\n\t{\n\t\tconst [\n\t\t\tcallee, calleeNote,\n\t\t] = breakBrackets(rawCallee, '[', ']')\n\n\t\tret.callee = callee\n\t\tret.calleeNote = calleeNote\n\t}\n\telse\n\t{\n\t\tret.callee = rawCallee\n\t}\n\n\tif (ret.callee === 'eval')\n\t{\n\t\tret.eval = true\n\t}\n\n\tif (testEvalSource === true)\n\t{\n\t\tif (!rawLine.startsWith(AT))\n\t\t{\n\t\t\treturn <IRawLineTrace>{\n\t\t\t\traw: true,\n\t\t\t\tindent,\n\t\t\t\trawLine,\n\t\t\t}\n\t\t}\n\t}\n\n\tObject.assign(\n\t\tret,\n\t\ttestEvalSource && isEvalSource(rawSource)\n\t\t\t? parseEvalSource(rawSource)\n\t\t\t: parseSource(rawSource),\n\t)\n\n\tif (testEvalSource === true)\n\t{\n\t\tif (!validTrace(ret))\n\t\t{\n\t\t\treturn <IRawLineTrace>{\n\t\t\t\traw: true,\n\t\t\t\tindent,\n\t\t\t\trawLine,\n\t\t\t}\n\t\t}\n\t}\n\n\tret.indent = indent\n\n\treturn ret\n}\n\nexport function isEvalSource(rawSource: string)\n{\n\treturn REGEX_STARTS_WITH_EVAL_AT.test(rawSource)\n}\n\nexport function validTrace(trace: ITraceValue)\n{\n\tif (isRawLineTrace(trace))\n\t{\n\t\treturn false;\n\t}\n\n\treturn trace.eval || isNumOnly(trace.line) || isUnset(trace.callee) && trace.source?.length > 0 && validPosition(trace);\n}\n\nexport function parseBody(rawStack: string, detectMessage?: string)\n{\n\tlet rawTrace: string[];\n\tlet rawMessage: string\n\n\tif (!isUnset(detectMessage))\n\t{\n\t\tlet { type, message } = parseMessage(rawStack, true);\n\n\t\tlet mf = formatMessage({\n\t\t\ttype,\n\t\t\tmessage: detectMessage === '' ? message : detectMessage,\n\t\t});\n\n\t\tlet i = rawStack.indexOf(mf)\n\n\t\tif (i === 0)\n\t\t{\n\t\t\tlet s = rawStack.replace(mf, '')\n\t\t\tlet m = R_CRLF.exec(s)\n\n\t\t\tif (m?.index === 0)\n\t\t\t{\n\t\t\t\trawTrace = lineSplit(m.input.replace(m[0], ''));\n\n\t\t\t\trawMessage = mf\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!rawMessage?.length)\n\t{\n\t\t([rawMessage, ...rawTrace] = lineSplit(rawStack));\n\n\t\t// A error message might have multiple lines\n\t\tconst index = rawTrace.findIndex(line => line.trimLeft()\n\t\t\t.startsWith(AT) && validTrace(parseTrace(trim(line), true)));\n\n\t\trawMessage = [rawMessage, ...rawTrace.splice(0, index)].join(LF)\n\t}\n\n\treturn {\n\t\trawMessage,\n\t\trawTrace,\n\t}\n}\n\nexport function parseMessage(body: string, looseMode?: boolean): IParsedWithoutTrace\n{\n\ttry\n\t{\n\t\tconst [, type, code, message] = body.match(looseMode ? REGEX_MATCH_MESSAGE_LOOSE : REGEX_MATCH_MESSAGE);\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tcode,\n\t\t\tmessage,\n\t\t}\n\t}\n\tcatch (e: any)\n\t{\n\t\te.message = `Failed to parse error message.\\nreason: ${e.message}\\nbody=${inspect(body)}`;\n\n\t\terrcode(e, {\n\t\t\tbody,\n\t\t});\n\n\t\tthrow e\n\t}\n}\n\nexport function parseStack(rawStack: string, detectMessage?: string): IParsed\n{\n\tif (typeof rawStack !== 'string')\n\t{\n\t\tthrow errcode(new TypeError('stack must be a string'), {\n\t\t\trawStack,\n\t\t\tdetectMessage,\n\t\t});\n\t}\n\n\ttry\n\t{\n\t\tconst { rawMessage, rawTrace } = parseBody(rawStack, detectMessage);\n\n\t\tconst {\n\t\t\ttype, code, message,\n\t\t} = parseMessage(rawMessage)\n\n\t\tconst traces = rawTrace.map(t => parseTrace(t, true))\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tcode,\n\t\t\tmessage,\n\t\t\ttraces,\n\t\t\trawMessage,\n\t\t\trawTrace,\n\t\t\trawStack,\n\t\t}\n\t}\n\tcatch (e: any)\n\t{\n\t\terrcode(e, {\n\t\t\trawStack,\n\t\t\tdetectMessage,\n\t\t});\n\n\t\tthrow e;\n\t}\n}\n\nexport function formatTrace({\n\tcallee,\n\tcalleeNote,\n\tsource,\n\tline,\n\tcol,\n}: ITSPickExtra<ITrace, 'source'>)\n{\n\tconst sourceTrace = [\n\t\tsource,\n\t\tline,\n\t\tcol,\n\t]\n\t\t.filter(v => typeof v !== 'undefined')\n\t\t.join(':')\n\n\tconst note = calleeNote\n\t\t? ` [${calleeNote}]`\n\t\t: ''\n\n\treturn callee\n\t\t? `${callee}${note} (${sourceTrace})`\n\t\t: sourceTrace\n}\n\nexport function formatEvalTrace({\n\tcallee,\n\tevalTrace,\n\n\tevalCallee,\n\tevalCalleeNote,\n\n\t...trace\n}: IEvalTrace)\n{\n\treturn `${callee} (eval at ${formatTrace({\n\t\t...trace,\n\n\t\tcallee: evalCallee ?? '<anonymous>',\n\t\tcalleeNote: evalCalleeNote,\n\t})}, ${formatTrace(evalTrace)})`;\n}\n\nexport function formatMessagePrefix({\n\ttype,\n\tcode,\n}: IParsedWithoutTrace)\n{\n\tif (code?.length)\n\t{\n\t\ttype += ` [${code}]`;\n\t}\n\n\treturn `${type}`;\n}\n\nexport function formatMessage(parsed: IParsedWithoutTrace)\n{\n\tlet line = formatMessagePrefix(parsed);\n\n\tif (typeof parsed.message !== 'undefined')\n\t{\n\t\tline += `: ${parsed.message ?? ''}`;\n\t}\n\n\treturn line;\n}\n\nexport function formatRawLineTrace(trace: IRawLineTrace)\n{\n\treturn `${trace.indent ?? '    '}${trace.rawLine}`\n}\n\nexport function isRawLineTrace(trace: ITraceValue): trace is IRawLineTrace\n{\n\treturn (trace.raw === true)\n}\n\nexport function isEvalTrace(trace: ITraceValue): trace is IEvalTrace\n{\n\treturn (trace as IEvalTrace).eval === true\n}\n\nexport function formatTraceLine(trace: ITraceValue)\n{\n\tif (isRawLineTrace(trace))\n\t{\n\t\treturn formatRawLineTrace(trace)\n\t}\n\n\treturn `${trace.indent ?? '    '}at ${\n\t\tisEvalTrace(trace)\n\t\t\t? formatEvalTrace(trace)\n\t\t\t: formatTrace(trace)\n\t}`\n}\n\nexport class ErrorStack implements IParsed\n{\n\n\t/**\n\t * Error type\n\t */\n\ttype: string;\n\n\tcode?: string;\n\t/**\n\t * The message used by Error constructor\n\t */\n\tmessage: string;\n\ttraces: IParsed[\"traces\"];\n\n\treadonly rawMessage?: string;\n\treadonly rawTrace?: string[];\n\treadonly rawStack?: string;\n\n\tconstructor(stack: string, detectMessage?: string)\n\t{\n\t\tObject.assign(this, parseStack(stack, detectMessage))\n\t}\n\n\t/**\n\t * filterFunction Function the same as the callback function of Array.prototype.filter(callback)\n\t */\n\tfilter(filter: (value: ITraceValue, index: number, array: IParsed[\"traces\"]) => boolean)\n\t{\n\t\tthis.traces = this.traces.filter(filter)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Format object parsed\n\t */\n\tformat()\n\t{\n\t\treturn stringifyErrorStack(this)\n\t}\n}\n\nexport function formatTraces(traces: IParsed[\"traces\"])\n{\n\treturn traces?.map(formatTraceLine)\n}\n\n/**\n * Format object parsed\n */\nexport function stringifyErrorStack(parsed: ITSRequireAtLeastOne<IParsed, 'traces' | 'rawTrace'>)\n{\n\tconst messageLines = `${formatMessage(parsed)}`\n\tconst tracesLines = (parsed.traces?.map(formatTraceLine) ?? parsed.rawTrace)\n\t\t.join(LF)\n\t;\n\n\treturn tracesLines\n\t\t? messageLines + LF + tracesLines\n\t\t: messageLines\n}\n\nexport function parseErrorStack(stack: string, detectMessage?: string)\n{\n\treturn new ErrorStack(stack, detectMessage)\n}\n\nexport default parseErrorStack\n"],"names":["trim","s","isUnset","v","isNumOnly","test","toString","AT","REGEX_MATCH_MESSAGE","REGEX_MATCH_MESSAGE_LOOSE","RegExp","source","flags","REGEX_REMOVE_AT","REGEX_STARTS_WITH_EVAL_AT","breakBrackets","str","first","last","endsWith","firstIndex","cursor","length","count","char","charAt","slice","map","validPosition","line","col","parseSource","rawSource","stringSplitWithLimit","parseEvalSource","rawEvalSource","indent","rawLine","_detectIndent","rawTrace","rawEvalTrace","replace","split","eval","ev","callee","evalCallee","calleeNote","evalCalleeNote","trace","parseTrace","evalTrace","body","detectIndentLine","testEvalSource","t","rawCallee","ret","startsWith","Object","assign","isEvalSource","validTrace","raw","_trace$source","isRawLineTrace","parseBody","rawStack","detectMessage","_rawMessage","rawMessage","type","message","parseMessage","mf","formatMessage","indexOf","m","R_CRLF","exec","index","lineSplit","input","findIndex","trimLeft","splice","join","LF","looseMode","code","match","e","inspect","errcode","parseStack","TypeError","traces","formatTrace","sourceTrace","filter","formatEvalTrace","formatMessagePrefix","parsed","_parsed$message","formatRawLineTrace","_trace$indent","isEvalTrace","formatTraceLine","_trace$indent2","ErrorStack","constructor","stack","this","format","stringifyErrorStack","formatTraces","_parsed$traces$map","_parsed$traces","messageLines","tracesLines","parseErrorStack"],"mappings":"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"}