!function(e, r) {
  "object" == typeof exports && "undefined" != typeof module ? r(exports, require("crlf-normalize"), require("string-split-keep2"), require("err-code"), require("util"), require("string-detect-indent")) : "function" == typeof define && define.amd ? define([ "exports", "crlf-normalize", "string-split-keep2", "err-code", "util", "string-detect-indent" ], r) : r((e = "undefined" != typeof globalThis ? globalThis : e || self).ErrorStack2 = {}, e.crlfNormalize, e.stringSplitKeep2, e.errcode, e.util, e.stringDetectIndent);
}(this, (function(e, r, a, t, n, i) {
  "use strict";
  function trim(e) {
    return e.trim();
  }
  function isUnset(e) {
    return null == e;
  }
  function isNumOnly(e) {
    return ("number" == typeof e || "string" == typeof e) && /^\d+$/.test(e.toString());
  }
  const s = "at", c = /^([a-z][a-z0-9_]*)(?:(?: \[(\w+)\])?:(?: ([\s\S]*))?)?$/i, o = /*#__PURE__*/ new RegExp(c.source, c.flags + "m"), l = /^at\s+/, u = /^eval\s+at\s+/;
  function breakBrackets(e, r, a) {
    if (!e.endsWith(a)) return [ e ];
    let t, n = e.length - 1, i = 1;
    for (;--n >= 0; ) {
      const s = e.charAt(n);
      if (s === a) i++; else if (s === r && 0 == --i) {
        t = n;
        break;
      }
    }
    return [ e.slice(0, t), e.slice(t + 1, -1) ].map(trim);
  }
  function validPosition(e) {
    return !isUnset(e) && ("object" == typeof e && isUnset(e.line) && isUnset(e.col) ? null : isNumOnly(e.line) && isNumOnly(e.col));
  }
  function parseSource(e) {
    const [r, t, n] = a.stringSplitWithLimit(e, ":", -3);
    return null != n && n.length && null != t && t.length ? {
      source: r,
      line: t,
      col: n
    } : {
      source: e
    };
  }
  function parseEvalSource(e) {
    const {indent: r, rawLine: a} = _detectIndent(e), [t, n] = a.replace(u, "").split(/,\s+/g).map(trim), {eval: i, callee: s, calleeNote: c, ...o} = parseTrace(t);
    return {
      evalCallee: s,
      evalCalleeNote: c,
      ...o,
      evalTrace: parseSource(n),
      indent: r
    };
  }
  function _detectIndent(e) {
    const {indent: r, body: a} = i.detectIndentLine(e);
    return {
      indent: r,
      rawLine: a
    };
  }
  function parseTrace(e, r) {
    const {indent: a, rawLine: t} = _detectIndent(e), n = t.replace(l, "");
    let [i, c] = breakBrackets(n, "(", ")");
    c || ([i, c] = [ c, i ]);
    const o = {};
    if (i) {
      const [e, r] = breakBrackets(i, "[", "]");
      o.callee = e, o.calleeNote = r;
    } else o.callee = i;
    return "eval" === o.callee && (o.eval = !0), !0 !== r || t.startsWith(s) ? (Object.assign(o, r && isEvalSource(c) ? parseEvalSource(c) : parseSource(c)), 
    !0 !== r || validTrace(o) ? (o.indent = a, o) : {
      raw: !0,
      indent: a,
      rawLine: t
    }) : {
      raw: !0,
      indent: a,
      rawLine: t
    };
  }
  function isEvalSource(e) {
    return u.test(e);
  }
  function validTrace(e) {
    var r;
    return !isRawLineTrace(e) && (e.eval || isNumOnly(e.line) || isUnset(e.callee) && (null === (r = e.source) || void 0 === r ? void 0 : r.length) > 0 && validPosition(e));
  }
  function parseBody(e, a) {
    var t;
    let n, i;
    if (!isUnset(a)) {
      let {type: t, message: s} = parseMessage(e, !0), c = formatMessage({
        type: t,
        message: "" === a ? s : a
      });
      if (0 === e.indexOf(c)) {
        let a = e.replace(c, ""), t = r.R_CRLF.exec(a);
        0 === (null == t ? void 0 : t.index) && (n = r.lineSplit(t.input.replace(t[0], "")), 
        i = c);
      }
    }
    if (null === (t = i) || void 0 === t || !t.length) {
      [i, ...n] = r.lineSplit(e);
      const a = n.findIndex((e => e.trimLeft().startsWith(s) && validTrace(parseTrace(trim(e), !0))));
      i = [ i, ...n.splice(0, a) ].join(r.LF);
    }
    return {
      rawMessage: i,
      rawTrace: n
    };
  }
  function parseMessage(e, r) {
    try {
      const [, a, t, n] = e.match(r ? o : c);
      return {
        type: a,
        code: t,
        message: n
      };
    } catch (r) {
      throw r.message = `Failed to parse error message.\nreason: ${r.message}\nbody=${n.inspect(e)}`, 
      t(r, {
        body: e
      }), r;
    }
  }
  function parseStack(e, r) {
    if ("string" != typeof e) throw t(new TypeError("stack must be a string"), {
      rawStack: e,
      detectMessage: r
    });
    try {
      const {rawMessage: a, rawTrace: t} = parseBody(e, r), {type: n, code: i, message: s} = parseMessage(a);
      return {
        type: n,
        code: i,
        message: s,
        traces: t.map((e => parseTrace(e, !0))),
        rawMessage: a,
        rawTrace: t,
        rawStack: e
      };
    } catch (a) {
      throw t(a, {
        rawStack: e,
        detectMessage: r
      }), a;
    }
  }
  function formatTrace({callee: e, calleeNote: r, source: a, line: t, col: n}) {
    const i = [ a, t, n ].filter((e => void 0 !== e)).join(":");
    return e ? `${e}${r ? ` [${r}]` : ""} (${i})` : i;
  }
  function formatEvalTrace({callee: e, evalTrace: r, evalCallee: a, evalCalleeNote: t, ...n}) {
    return `${e} (eval at ${formatTrace({
      ...n,
      callee: null != a ? a : "<anonymous>",
      calleeNote: t
    })}, ${formatTrace(r)})`;
  }
  function formatMessagePrefix({type: e, code: r}) {
    return null != r && r.length && (e += ` [${r}]`), `${e}`;
  }
  function formatMessage(e) {
    let r = formatMessagePrefix(e);
    var a;
    return void 0 !== e.message && (r += `: ${null !== (a = e.message) && void 0 !== a ? a : ""}`), 
    r;
  }
  function formatRawLineTrace(e) {
    var r;
    return `${null !== (r = e.indent) && void 0 !== r ? r : "    "}${e.rawLine}`;
  }
  function isRawLineTrace(e) {
    return !0 === e.raw;
  }
  function isEvalTrace(e) {
    return !0 === e.eval;
  }
  function formatTraceLine(e) {
    var r;
    return isRawLineTrace(e) ? formatRawLineTrace(e) : `${null !== (r = e.indent) && void 0 !== r ? r : "    "}at ${isEvalTrace(e) ? formatEvalTrace(e) : formatTrace(e)}`;
  }
  class ErrorStack {
    constructor(e, r) {
      Object.assign(this, parseStack(e, r));
    }
    filter(e) {
      return this.traces = this.traces.filter(e), this;
    }
    format() {
      return stringifyErrorStack(this);
    }
  }
  function stringifyErrorStack(e) {
    var a, t;
    const n = `${formatMessage(e)}`, i = (null !== (a = null === (t = e.traces) || void 0 === t ? void 0 : t.map(formatTraceLine)) && void 0 !== a ? a : e.rawTrace).join(r.LF);
    return i ? n + r.LF + i : n;
  }
  function parseErrorStack(e, r) {
    return new ErrorStack(e, r);
  }
  e.ErrorStack = ErrorStack, e._detectIndent = _detectIndent, e.breakBrackets = breakBrackets, 
  e.default = parseErrorStack, e.formatEvalTrace = formatEvalTrace, e.formatMessage = formatMessage, 
  e.formatMessagePrefix = formatMessagePrefix, e.formatRawLineTrace = formatRawLineTrace, 
  e.formatTrace = formatTrace, e.formatTraceLine = formatTraceLine, e.formatTraces = function formatTraces(e) {
    return null == e ? void 0 : e.map(formatTraceLine);
  }, e.isEvalSource = isEvalSource, e.isEvalTrace = isEvalTrace, e.isRawLineTrace = isRawLineTrace, 
  e.parseBody = parseBody, e.parseErrorStack = parseErrorStack, e.parseEvalSource = parseEvalSource, 
  e.parseMessage = parseMessage, e.parseSource = parseSource, e.parseStack = parseStack, 
  e.parseTrace = parseTrace, e.stringifyErrorStack = stringifyErrorStack, e.validPosition = validPosition, 
  e.validTrace = validTrace, Object.defineProperty(e, "__esModule", {
    value: !0
  });
}));
//# sourceMappingURL=index.umd.production.min.cjs.map
