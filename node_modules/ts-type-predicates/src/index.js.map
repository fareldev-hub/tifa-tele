{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":";;;AAAA,mCAAwC;AAExC,SAAgB,iBAAiB,CAAa,MAAa,EAAE,aAAiD,IAAI;IAEjH,UAAU,aAAV,UAAU,cAAV,UAAU,IAAV,UAAU,GAAK,IAAI,EAAC;IAEpB,IAAI,OAAO,UAAU,KAAK,UAAU,EACpC;QACC,UAAU,GAAG,CAAC,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;KAClC;IAED,OAAO,UAAU,CAAA;AAClB,CAAC;AAVD,8CAUC;AAED;;;;;GAKG;AACH,SAAgB,cAAc,CAAa,MAAa,EAAE,aAAkD,IAAI,EAAE,OAAgB,EAAE,gBAA0B;IAE7J,UAAU,GAAG,iBAAiB,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;IAEnD,IAAI,UAAU,KAAK,IAAI,IAAI,gBAAgB,KAAK,IAAI,EACpD;QACC,MAAM,IAAI,uBAAc,CAAC;YACxB,OAAO,EAAE,OAAO,aAAP,OAAO,cAAP,OAAO,GAAI,UAAU,MAAM,kBAAkB;YACtD,MAAM;YACN,QAAQ,EAAE,UAAU;YACpB,QAAQ,EAAE,gBAAgB;SAC1B,CAAC,CAAA;KACF;AACF,CAAC;AAbD,wCAaC;AAED,SAAgB,YAAY,CAAa,MAAa,EAAE,aAAkD,IAAI,EAAE,OAAgB;IAE/H,UAAU,GAAG,iBAAiB,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;IAEnD,IAAI,UAAU,KAAK,IAAI,EACvB;QACC,UAAU,GAAG,KAAK,CAAC;KACnB;IAED,OAAO,UAAU,CAAA;AAClB,CAAC;AAVD,oCAUC;AAED,kBAAe,cAAc,CAAC","sourcesContent":["import { AssertionError } from 'assert';\n\nexport function _handleExpression<T, P = any>(actual: T | P, expression: boolean | ((actual: T | P) => any) = true)\n{\n\texpression ??= true;\n\n\tif (typeof expression === 'function')\n\t{\n\t\texpression = !!expression(actual);\n\t}\n\n\treturn expression\n}\n\n/**\n * use asserts for make type predicates work\n *\n * @see https://www.typescriptlang.org/docs/handbook/advanced-types.html#using-type-predicates\n * @see https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions\n */\nexport function typePredicates<T, P = any>(actual: T | P, expression : boolean | ((actual: T | P) => any) = true, message?: string, ignoreExpression?: boolean): asserts actual is T\n{\n\texpression = _handleExpression(actual, expression);\n\n\tif (expression !== true && ignoreExpression !== true)\n\t{\n\t\tthrow new AssertionError({\n\t\t\tmessage: message ?? `actual ${actual} not as expected`,\n\t\t\tactual,\n\t\t\texpected: expression,\n\t\t\toperator: 'typePredicates',\n\t\t})\n\t}\n}\n\nexport function typeNarrowed<T, P = any>(actual: T | P, expression : boolean | ((actual: T | P) => any) = true, message?: string): actual is T\n{\n\texpression = _handleExpression(actual, expression);\n\n\tif (expression !== true)\n\t{\n\t\texpression = false;\n\t}\n\n\treturn expression\n}\n\nexport default typePredicates;\n"]}